<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>多仓库合并</title>
    <link href="/2023/05/22/Git/%E5%A4%9A%E4%BB%93%E5%BA%93%E5%90%88%E5%B9%B6/"/>
    <url>/2023/05/22/Git/%E5%A4%9A%E4%BB%93%E5%BA%93%E5%90%88%E5%B9%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="git-多仓库合并"><a href="#git-多仓库合并" class="headerlink" title="git 多仓库合并"></a>git 多仓库合并</h1><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>一般来说，git 仓库是不用轻易改动的，但是公司的其中一个管理后台项目拆成了十个 git 仓库，最惊人的是跑项目又要新建一个 project 目录，把这十个仓库克隆到 project 里面，根目录是projec, 底下有 A，B，C…等加起来十个目录，需要放在一起才能跑，最要命的是，readme还没说明怎么跑，仓库是分开的，你还不知道有几个要clone，导致跑项目都要摸索半天。我当时就惊了，既然这十个项目无法单独跑起来，又要拆十个仓库，这不是空有微前端的皮，没有微前端的魂吗，当时咋想的？并且分开增加了提交代码的工作量，假设一次改五个项目，那么每次合代码都会提五个merge，就不说后期改 bug 再次提交了；总结来说：当时这个方案毫无卵用。</p><h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><p>吐槽归吐槽，既然这么坑，肯定是要把这十个目录放到一个目录底下,并且是保持原来的目录，简单的仓库 merge 会导致目录打平。</p><h3 id="方案一-不推荐"><a href="#方案一-不推荐" class="headerlink" title="方案一(不推荐)"></a>方案一(不推荐)</h3><p>把所有项目克隆到 project 项目，删掉每个项目的 .git 目录，把 project 项目初始化为 git 仓库，推到远程即可，但是这个方法的缺陷是会丢失所有仓库的commit，所以只是作为兜底的方案，一般不用。</p><h3 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h3><p><strong>为了方便说明，我们分别用用两个目录A，B示例，合成一个仓库</strong></p><p>思路介绍：</p><ol><li>把A，B仓库，克隆名到为 <code>old_project</code> 的文件夹下<br>一定重新常见文件夹 old_project，不要直接用原来存在的开发目录，后面会对old_project做修改，除非你确定不再需要修改原开发目录。<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建目录</span><br>mkdir project <br>cd project<br><span class="hljs-meta prompt_"># </span><span class="language-bash">克隆仓库</span><br>git clone htts://xxx.com/A<br>git clone htts://xxx.com/B<br></code></pre></td></tr></table></figure></li></ol><p>old_project 的文件夹目录应该如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">old_project<br>|----A<br>|----B<br></code></pre></td></tr></table></figure><ol start="2"><li>再初始化一个新项目 <code>project</code>，示例 old_project 和 project 是同级目录，这个在后面的路径使用很重要，如果不是同目录，需要清楚这两个目录的层级关系</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir project<br>cd project<br><span class="hljs-meta prompt_"># </span><span class="language-bash">初始化仓库</span><br>git init<br><span class="hljs-meta prompt_"># </span><span class="language-bash">默认是 master 分支，建议切到一个用来 merge 的分支，误操作后还能重新基于 master 创建分支。</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置新仓库的远程源</span><br>git remote add origin htts://xxx.com/project<br></code></pre></td></tr></table></figure><p>前面步骤比较简单，这时候关键步骤来了，<strong>下面的步骤千万不能省略</strong>，需要用 <code>git mv</code> 指令对文件进行转移，并且不会丢失 commit 记录。</p><ol start="3"><li>回到 old_project 目录，把各个目录下的文件收拢到一个目录，这是必要的步骤</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">进入其中一个子目录</span><br>cd old_project/A<br>git checkout master # 看情况选择自己需要合并的分支 默认master<br>mkdir A # 没错 再建一个A目录，如果想重命名，可以改<br><span class="hljs-meta prompt_"># </span><span class="language-bash">B目录只要把 两处 A 改成 B 即可</span><br>ls -A | grep -wv &#x27;.git\|A&#x27; xargs -t -I &#x27;file&#x27; git mv file A/file<br>git add .<br>git commit -m &#x27;chore: A仓库合并&#x27;<br></code></pre></td></tr></table></figure><p>我们来看一下执行完的文件目录结构：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">old_project<br>|--A<br>|  |-A<br>|--B<br>|  |-B<br></code></pre></td></tr></table></figure><p><strong>B 仓库重复上述步骤即可</strong>，不用推送到远端</p><ol start="4"><li>回到项目 project 目录，添加 old_project 作为 project 的源。</li></ol><p>添加远程的命令为：<code>git remote add &lt;远程源别名&gt; &lt;远程源地址&gt;</code></p><p>我们平时拉项目的时候，相当于 git remote add origin <a href="https://xxx.com/old_project">https://xxx.com/old_project</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd project<br><span class="hljs-meta prompt_"># </span><span class="language-bash">把A仓库添加为别名A，源地址可以使链接，也可以是本地路径</span><br>git remote add A ../old_project/A<br>git remote add B ../old_project/B<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看 远程源</span><br>git remote -v<br><span class="hljs-meta prompt_"># </span><span class="language-bash">todo 补充 remote 命令结果</span><br>git fetch --all<br></code></pre></td></tr></table></figure><p>设置了源以后，我们的分支从这个源来创建，回到 project 项目：<br>分别从刚才的目录创建两个分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd project<br>git checkout -b A origin/A<br>git checkout -b B origin/B<br></code></pre></td></tr></table></figure><p>把本地的 old_project 当做源，创建两个分支，此时对于 old_project 下的文件结构是这样：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">old_project<br>|--A<br>|  |-A<br>|--B<br>|  |-B<br></code></pre></td></tr></table></figure><p>对于 A 仓库来说，它里面还有一个A目录，B 也是如此，我们要把 A 搬到新项目 project 目录下，就必须对其进行打包为一个目录，否则合并的时候，A，B目录合并到新项目目录会打平，造成冲突。</p><p>下面开始合并仓库：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">git merge A --allow-unrelated-histories <br>git merge B --allow-unrelated-histories <br></code></pre></td></tr></table></figure><p><code>--allow-unrelated-histories</code> 这个参数允许无关提交历史合并，两个仓库合并如果没有这个参数，git 是拒绝合并过程的。</p><p>最后，再把新仓库的代码提交，push 到远端，就能得到与原来目录相同的仓库啦。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>再次总结一下移动的思路，</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>1.单例模式</title>
    <link href="/2023/05/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/05/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="一、单例模式"><a href="#一、单例模式" class="headerlink" title="一、单例模式"></a>一、单例模式</h1><p>单例模式指的是无论调用多少次生成函数，都只会返回相同的实例。在这之前，你需要对闭包有些许了解.</p><p>假设我们需要创建一个可复用的弹窗，一旦有了这个弹窗，就不再重复创建 div，大概逻辑如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> temp = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 单例模式的关键变量</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Modal</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 如果有缓存 直接返回缓存内容</span><br>  <span class="hljs-keyword">if</span> (temp) &#123;<br>    <span class="hljs-keyword">return</span> temp;<br>  &#125;<br>  <span class="hljs-keyword">return</span> (temp = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;div&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码非常的简单，仅仅是使用一个 <code>temp</code> 变量缓存了 div 这个节点，一旦创建过就不会重复创建，这就是单例模式的核心原理：缓存。接下来让我们完善这个功能：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> temp = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 缓存变量 用于缓存稍后创建的弹窗</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 创建弹窗函数</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">弹窗内容</span>&#125; <span class="hljs-variable">modalContent</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Modal</span>(<span class="hljs-params">modalContent</span>) &#123;<br>  <span class="hljs-comment">// 如果有缓存 直接返回缓存内容</span><br>  <span class="hljs-keyword">if</span> (temp) &#123;<br>    temp.<span class="hljs-property">innerHTML</span> = modalContent;<br>    <span class="hljs-keyword">return</span> temp;<br>  &#125;<br>  <span class="hljs-keyword">const</span> body = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;body&quot;</span>); <span class="hljs-comment">// 如果没有创建新的弹窗</span><br>  <span class="hljs-keyword">const</span> div = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;div&quot;</span>);<br>  div.<span class="hljs-property">innerHTML</span> = modalContent;<br>  body.<span class="hljs-title function_">appendChild</span>(div);<br>  <span class="hljs-keyword">return</span> (temp = div);<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们来使用这个弹窗函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> modal1 = <span class="hljs-title class_">Modal</span>(<span class="hljs-string">&quot;modal1&quot;</span>); <span class="hljs-comment">// 第一次执行由于没有缓存，会执行后面的创建过程</span><br><span class="hljs-keyword">const</span> modal2 = <span class="hljs-title class_">Modal</span>(<span class="hljs-string">&quot;modal2&quot;</span>); <span class="hljs-comment">// 第二次有了缓存，直接返回了temp 正是第一次创建好的temp</span><br>modal1 === modal12; <span class="hljs-comment">// 结果是 true</span><br></code></pre></td></tr></table></figure><p>到此为止单例模式的核心已经讲完了，有项目经验的同学肯定发现了 <code>temp</code> 是一个外部变量，会污染命名空间，我们需要使用闭包的方式创建缓存变量，闭包可以简单解释为是函数创建的变量环境，属于函数上下文，作用是不会污染全局上下文。</p><p>现在我们对上述例子进行改造：<br>其实除了使用 <code>IIFE</code> 立即执行函数创建闭包变量以外，没有什么其他的不同，但是这个例子仍不是完美的，看完示例代码你可以自己思考一分钟，答案会在后面揭晓。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> <span class="hljs-title class_">Modal</span> = (<span class="hljs-keyword">function</span> (<span class="hljs-params">modalContent</span>) &#123;<br>  <span class="hljs-keyword">let</span> temp = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 缓存变量 用于缓存稍后创建的弹窗</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 如果有缓存 直接返回缓存内容</span><br>    <span class="hljs-keyword">if</span> (temp) &#123;<br>      temp.<span class="hljs-property">innerHTML</span> = modalContent;<br>      <span class="hljs-keyword">return</span> temp;<br>    &#125;<br>    <span class="hljs-keyword">const</span> body = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;body&quot;</span>); <span class="hljs-comment">// 如果没有创建新的弹窗</span><br>    <span class="hljs-keyword">const</span> div = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;div&quot;</span>);<br>    div.<span class="hljs-property">innerHTML</span> = modalContent;<br>    body.<span class="hljs-title function_">appendChild</span>(div);<br>    <span class="hljs-keyword">return</span> (temp = div);<br>  &#125;;<br>&#125;)();<br></code></pre></td></tr></table></figure><p>上述例子到底有什么缺陷呢，假如我今天需要复用弹窗，明天需要复用其他的东西，就不得不再次为某个具体的业务创造单例模式，那么我们在单例模式使用到达一定数量的时候，就需要考虑使用工厂函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/** 单例工厂函数 */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">SingletonbFactory</span>(<span class="hljs-params">Fn</span>) &#123;<br>  <span class="hljs-keyword">let</span> instance = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 实例缓存</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (instance) <span class="hljs-keyword">return</span> instance; <span class="hljs-comment">// 如果有直接返回</span><br>    <span class="hljs-keyword">return</span> (instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Fn</span>(<span class="hljs-variable language_">arguments</span>));<br>  &#125;;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Modal</span>(<span class="hljs-params">modalContent</span>) &#123;<br>  <span class="hljs-keyword">const</span> body = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;body&quot;</span>); <span class="hljs-comment">// 如果没有创建新的弹窗</span><br>  <span class="hljs-keyword">const</span> div = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;div&quot;</span>);<br>  div.<span class="hljs-property">innerHTML</span> = modalContent;<br>  body.<span class="hljs-title function_">appendChild</span>(div);<br>  <span class="hljs-keyword">return</span> div;<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">SingleModal</span> = <span class="hljs-title class_">SingletonFactory</span>(<span class="hljs-title class_">Modal</span>); <span class="hljs-comment">// 工厂函数包装需要作为单例的函数</span><br><br><span class="hljs-keyword">const</span> modal1 = <span class="hljs-title class_">SingleModal</span>(<span class="hljs-string">&quot;modal1&quot;</span>); <span class="hljs-comment">// 弹窗命名为 modal1</span><br><span class="hljs-keyword">const</span> modal2 = <span class="hljs-title class_">SingleModal</span>(<span class="hljs-string">&quot;modal2&quot;</span>); <span class="hljs-comment">// 弹窗命名为 modal2</span><br><br>modal1 === modal1; <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>可能你会好奇，为什么要这么设计，这不是增加了理解难度吗？是的，这会增加代码的复杂度，万事都是有两面性的，使用设计模式需要学习成本。但是这在大型项目中是非常有价值的，以来这种方式符合函数式编程的理念，专业术语叫做 <code>AOP</code> （面向切面编程）。这样做的价值在于把函数指责分开了，单例的工厂函数只负责缓存责任，实现具体业务的函数则不去负责这个事情，遵循函数单一职责原则。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>2.策略模式</title>
    <link href="/2023/05/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/05/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="二、策略模式"><a href="#二、策略模式" class="headerlink" title="二、策略模式"></a>二、策略模式</h1><p>笔者使用过的设计模式中，策略模式是常用的模式并且非常的实用。举一个小例子你可能会恍然大悟，原来你一直在用，只不过不知道它叫<code>策略模式</code>，策略模式用在那些代码结构相似但是内部逻辑不相同的场景。</p><br><p>现在有一个需求，要你在页面上展示今天是星期几，你会怎么做？可以试着给自己一分钟思考；时间到，第一点，我们要知道 <code>JavaScript</code> 的日期实例 <code>new Date().getDay()</code> 能够返回今天星期几的数字，<code>0</code> 代表星期天，<code>1</code> 代表星期一,<code>2</code> 代表星期二 … 以此类推。假设我们不知道什么设计模式，代码雏形应该是这样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getDayDesc</span>(<span class="hljs-params">day</span>) &#123;<br>  <span class="hljs-keyword">switch</span> (day) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;星期天&#x27;</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;星期一&#x27;</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;星期二&#x27;</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;星期三&#x27;</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;星期四&#x27;</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;星期五&#x27;</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;星期六&#x27;</span><br>  &#125;<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;今天是&#x27;</span>, <span class="hljs-title function_">getDayDesc</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getDay</span>()));<br><br></code></pre></td></tr></table></figure><p>一般来说这是大部人第一时间想到的方案，确实也是可以实现功能的，但是一眼看去，似乎重复的部分有点多，并且我要修改<code>星期一</code>为<code>周一</code>，就要改动函数，这违反了函数的设计规则：开放封闭原则。开放封闭原则指的是对函数的扩展开发，对修改封闭，不允许修改已有的逻辑。策略模式用的最多的就是对象，我们尝试用对象封装这个策略：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> daysObj = &#123;<br>  <span class="hljs-number">0</span>: <span class="hljs-string">&#x27;星期天&#x27;</span>,<br>  <span class="hljs-number">1</span>: <span class="hljs-string">&#x27;星期一&#x27;</span>,<br>  <span class="hljs-number">2</span>: <span class="hljs-string">&#x27;星期二&#x27;</span>,<br>  <span class="hljs-number">3</span>: <span class="hljs-string">&#x27;星期三&#x27;</span>,<br>  <span class="hljs-number">4</span>: <span class="hljs-string">&#x27;星期四&#x27;</span>,<br>  <span class="hljs-number">5</span>: <span class="hljs-string">&#x27;星期五&#x27;</span>,<br>  <span class="hljs-number">6</span>: <span class="hljs-string">&#x27;星期六&#x27;</span>,<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getDayDesc</span>(<span class="hljs-params">day, strategyObj</span>) &#123;<br>  <span class="hljs-keyword">return</span> strategyObj[day]<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;今天是&#x27;</span>, <span class="hljs-title function_">getDayDesc</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getDay</span>(), daysObj));<br></code></pre></td></tr></table></figure><p>上面的代码看起来有点奇怪，怪在下标是数字，因此可以用数组来表达：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><br><span class="hljs-keyword">const</span> daysSet = [<br>  <span class="hljs-string">&#x27;星期天&#x27;</span>,<br>  <span class="hljs-string">&#x27;星期一&#x27;</span>,<br>  <span class="hljs-string">&#x27;星期二&#x27;</span>,<br>  <span class="hljs-string">&#x27;星期三&#x27;</span>,<br>  <span class="hljs-string">&#x27;星期四&#x27;</span>,<br>  <span class="hljs-string">&#x27;星期五&#x27;</span>,<br>  <span class="hljs-string">&#x27;星期六&#x27;</span>,<br>]<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getDayDesc</span>(<span class="hljs-params">day, strategyObj</span>) &#123;<br>  <span class="hljs-keyword">return</span> strategyObj[day]<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;今天是&#x27;</span>, <span class="hljs-title function_">getDayDesc</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getDay</span>(), daysSet));<br></code></pre></td></tr></table></figure><p>假设哪天产品要求你把星期改为周，你只需如下改动并且能长久复用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> daysSet = [<br>  <span class="hljs-string">&#x27;周日&#x27;</span>,<br>  <span class="hljs-string">&#x27;周一&#x27;</span>,<br>  <span class="hljs-string">&#x27;周二&#x27;</span>,<br>  <span class="hljs-string">&#x27;周三&#x27;</span>,<br>  <span class="hljs-string">&#x27;周四&#x27;</span>,<br>  <span class="hljs-string">&#x27;周五&#x27;</span>,<br>  <span class="hljs-string">&#x27;周六&#x27;</span>,<br>]<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getDayDesc</span>(<span class="hljs-params">day, strategyObj</span>) &#123;<br>  <span class="hljs-keyword">return</span> strategyObj[day]<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;今天是&#x27;</span>, <span class="hljs-title function_">getDayDesc</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getDay</span>(), daysSet));<br></code></pre></td></tr></table></figure><p>我们没有动函数的内部功能，不需要担心其他使用 <code>getDayDesc</code> 的人会有问题。</p><p>现在假设有更复杂的，周一我要提醒大家需要升国旗并且要调用接口下发通知，那么现在的功能就变得有点不适用了，我们策略只返回了 string 类型，无法做到更多的事，我们需要修改为兼容函数类型：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> daysObj = &#123;<br>  <span class="hljs-number">0</span>: <span class="hljs-string">&#x27;周日&#x27;</span>,<br>  <span class="hljs-number">1</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-title function_">ajax</span>(<span class="hljs-string">&#x27;/notice&#x27;</span>)<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;今天周一，早上要升国旗&#x27;</span><br>  &#125;,<br>  <span class="hljs-number">2</span>: <span class="hljs-string">&#x27;周二&#x27;</span>,<br>  <span class="hljs-number">3</span>: <span class="hljs-string">&#x27;周三&#x27;</span>,<br>  <span class="hljs-number">4</span>: <span class="hljs-string">&#x27;周四&#x27;</span>,<br>  <span class="hljs-number">5</span>: <span class="hljs-string">&#x27;周五&#x27;</span>,<br>  <span class="hljs-number">6</span>: <span class="hljs-string">&#x27;周六&#x27;</span>,<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getDayDesc</span>(<span class="hljs-params">day, strategyObj</span>) &#123;<br>  <span class="hljs-keyword">const</span> strategy = strategyObj[day]<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> strategy === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">strategy</span>()<br>  &#125;<br>  <span class="hljs-keyword">return</span> strategy<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;今天是&#x27;</span>, <span class="hljs-title function_">getDayDesc</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getDay</span>(), daysObj));<br><br></code></pre></td></tr></table></figure><p>兼容了函数类型，使得我们的策略模式非常的灵活并且这个函数是不会轻易被修改的。</p><p>到这里这算是一个非常完整的策略模式改造，这里有个细节是我重新加上了key，方便全是函数的时候作区分。你如果配置过 loader， 一定也能发现很多loader即支持字符串也支持函数，背后的设计大概也是这个样子。<br>大家日常开发一定经常用这个设计模式，，本章的例子策略是固定七个，但是业务中常常需要扩展非常多的功能，这时候策略模式的威力才真正得以展现。下一章，我们说说 <code>代理模式</code>。</p><h3 id="小试牛刀"><a href="#小试牛刀" class="headerlink" title="小试牛刀"></a>小试牛刀</h3><p>假设公司的绩效等级分为 A，B，C，D，E 年终奖对应的绩点为 2，1.8，1.5，1.1，0.8。假设年终基数为 base，年终奖为：年终基数 * 绩点。已知绩效等级，求员工的年终奖，答案将在下一章揭晓。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>3.代理模式</title>
    <link href="/2023/05/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/3-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/05/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/3-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><p><strong>我们来回顾上一章策略模式留下的问题：</strong></p><br>假设公司的绩效等级分为 A，B，C，D，E 年终奖对应的绩点为 2，1.8，1.5，1.1，0.8。假设年终基数为 base，年终奖为：年终基数 * 绩点。已知绩效等级，求员工的年终奖。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 绩效等级和绩点的映射关系</span><br><span class="hljs-keyword">const</span> levelToCredit = &#123;<br>    <span class="hljs-attr">A</span>: <span class="hljs-number">2</span>,<br>    <span class="hljs-attr">B</span>: <span class="hljs-number">1.8</span>,<br>    <span class="hljs-attr">C</span>: <span class="hljs-number">1.5</span>,<br>    <span class="hljs-attr">D</span>: <span class="hljs-number">1.1</span>,<br>    <span class="hljs-attr">E</span>: <span class="hljs-number">0.8</span><br>&#125;<br><br><span class="hljs-comment">// 年终奖计算逻辑</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getsalary</span>(<span class="hljs-params">base, level</span>) &#123;<br>  <span class="hljs-keyword">return</span> levelToCredit[level] * base<br>&#125;<br></code></pre></td></tr></table></figure><p>代理模式，有点像经纪人的角色，可以完成非核心事务。假设我们要使用一个函数在页面加载一张图片，代码应该是这样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> imgNode = (<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> imgNode = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;img&#x27;</span>)<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(imgNode)<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">setSrc</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">src</span>) &#123;<br>      imgNode.<span class="hljs-property">src</span> = src<br>    &#125;<br>  &#125;<br>&#125;)()<br><br>imgNode.<span class="hljs-title function_">setSrc</span>(<span class="hljs-string">&#x27;https://img.com/banner.png&#x27;</span>) <span class="hljs-comment">// 加载图片</span><br></code></pre></td></tr></table></figure><p>事实上，我们调用 setSrc 的时候，会发起一个网络请求，在图片资源返回前，图片是空白的，为了避免图片返回的时候闪烁，我们为图片增加 loading 的情况。假设一开始直接修改上述代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> imgNode = (<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 真正展示图片的节点</span><br>  <span class="hljs-keyword">const</span> imgNode = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;img&#x27;</span>)<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(imgNode)<br>  <span class="hljs-comment">// 代理节点</span><br>  <span class="hljs-keyword">var</span> proxyImg = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;img&#x27;</span>)<br>  <span class="hljs-comment">// 当代理图片加载完成的时候，把图片的链接赋值给展示节点</span><br>  proxyImg.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    imgNode.<span class="hljs-title function_">setSrc</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">src</span>)<br>  &#125;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">setSrc</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">src</span>) &#123;<br>      <span class="hljs-comment">// 预先loading</span><br>      imgNode.<span class="hljs-property">src</span> = <span class="hljs-string">&#x27;https://img.com/loading.gif&#x27;</span><br>      <span class="hljs-comment">// 代理节点开始请求图片数据</span><br>      proxyImg.<span class="hljs-property">src</span> = src<br>    &#125;<br>  &#125;<br>&#125;)()<br><br>imgNode.<span class="hljs-title function_">setSrc</span>(<span class="hljs-string">&#x27;https://img.com/banner.png&#x27;</span>) <span class="hljs-comment">// 加载图片</span><br></code></pre></td></tr></table></figure><p>这样的代码相信是很多人的第一选择，包括我开始想到的方案也是这样的，那这样的代码有什么缺点呢？<br>在未来假设网速快到极致，这样 loading 占位的图片反而导致页面闪烁，这时候如果想把代理的方式去掉，就要修改函数的逻辑，那这样就违反了开放封闭的原则。<br>并且代理和创建节点，这两个职责耦合到了一个函数，也违反单一职责原则。不过大家现在可能仅仅知道我们要遵守这些原则，至于为什么，比较少人考究，也很少文章详细解释为什么。<br>以我个人的开发经验来说，可以这么理解：</p><p>假设某个需求里面有 A 和 B 两个功能，B 功能是帮 A 做一些事；小王同学把这两个功能都写在了函数 F 里，某一天，产品要砍掉 B 这个功能，然后这时小王离职了，小李接替他的工作来砍掉B，小李看完代码发现砍掉 B 得修改整个 F 函数，小李不仅要看懂函数 F，还要把 B 功能从 F 里面剔除，并且最后还要保证不影响 A 功能。这么一顿操作，小李感觉整个人都不好了，因为他只是想砍掉 B。<br>不幸的是他还要同时了解 A 功能，F 函数的代码接口以及修改。这样的开发模式在大型应用里面时非常致命的，容易导致整个项目稳定性过差，并且开发的代码容易成为相互的心智负担。</p><p>假设我们使用代理模式把 B 分离出去，回到上面的例子，首先我们是没有代理的代码，imgNode 函数负责生成一张图片：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs js"><br><br><span class="hljs-keyword">var</span> imgNode = (<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 创建展示的图片节点</span><br>  <span class="hljs-keyword">const</span> imgNode = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;img&#x27;</span>)<br>  <span class="hljs-comment">// 挂载到body</span><br>  <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(imgNode)<br>  <span class="hljs-comment">// 暴露setSrc</span><br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">setSrc</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">src</span>) &#123;<br>      imgNode.<span class="hljs-property">src</span> = src<br>    &#125;<br>  &#125;<br>&#125;)()<br><br><br><span class="hljs-keyword">var</span> proxyImg = (<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-comment">// 图片节点</span><br>  <span class="hljs-keyword">let</span> node = <span class="hljs-literal">null</span><br>  <span class="hljs-comment">// 创建代理节点</span><br>  <span class="hljs-keyword">const</span> proxyImg = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;img&#x27;</span>)<br>  <span class="hljs-comment">// 图片加载完成 把node设置为代理图片的src</span><br>  proxyImg.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    node.<span class="hljs-title function_">setSrc</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">src</span>)<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">imgNode</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">setSrc</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">src</span>) &#123;<br>        <span class="hljs-comment">// 使用代理图片节点请求</span><br>        proxyImg.<span class="hljs-property">src</span> = src<br>        <span class="hljs-comment">// 缓存 node</span><br>        node = imgNode<br>        <span class="hljs-comment">// 把展示图片节点的图片设置为 loading</span><br>        img.<span class="hljs-title function_">setSrc</span>(<span class="hljs-string">&#x27;https://img.com/loading.png&#x27;</span>)<br>      &#125;<br>  &#125;<br>  &#125;<br>&#125;)()<br><br><span class="hljs-keyword">const</span> img = <span class="hljs-title function_">proxyImg</span>(imgNode)<br>img.<span class="hljs-title function_">setSrc</span>(<span class="hljs-string">&#x27;https://img.com/banner.png&#x27;</span>)<br></code></pre></td></tr></table></figure><p>这里 proxyImg 这个函数完全是一个锦上添花的功能，假设未来网速快到一定程度，这种     loading 可以淘汰，那我们不需要代理也能正常使用，把  <code>img.setSrc</code> 换成 <code>imgNode.setSrc</code> 实现功能。那么代理模式有什么特点呢，首先实现了和原功能一样的 api 这样在取消使用代理模式的时候也不会因为 api 的差异性而进行大改。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>4.发布订阅模式</title>
    <link href="/2023/05/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/4-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/05/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/4-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>很多文章都把 <code>发布订阅模式</code> 和 <code>观察者模式</code>区别开来，从根本来说是同一种设计模式。抛开代码，假设我们订阅某个频道的咨询，一旦有新资讯发布，就能立即收到通知。我们只需要订阅某个事件即可。</p><p>我们经常使用的 DOM 事件，使用的就是发布订阅模式，我们逐步解析：</p><blockquote><p>摘录来自: 曾探. “JavaScript设计模式与开发实践 (图灵原创)。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">addEventListener</span>( <span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-number">2</span>);<br>&#125;, <span class="hljs-literal">false</span> );<br><br><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">click</span>();    <span class="hljs-comment">// 模拟用户点击”</span><br></code></pre></td></tr></table></figure><p>如上代码，我们订阅 body 上面的点击事件，并告知事件中心要执行一个回调函数。当触发点击事件的时候，事件中心会触发我们注册的回调函数。</p><p>回想 node 的发布订阅模式，有一个事件中心 EventEmitter：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> <span class="hljs-title class_">EventEmitter</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;events&#x27;</span>).<span class="hljs-property">EventEmitter</span>; <br><span class="hljs-keyword">var</span> event = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EventEmitter</span>(); <br>event.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;hello&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;hello 大家好&#x27;</span>); <br>&#125;); <br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br>    event.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;hello&#x27;</span>); <br>&#125;, <span class="hljs-number">1000</span>); <br></code></pre></td></tr></table></figure><p>上述代码 通过 event.on 注册了  <code>hello</code> 事件，一秒后又触发了这个事件，并执行了事件对应的回调。参照上述例子，我们 使用 on 方法注册监听，emit 方法触发监听，Let’s go:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyEvent</span> &#123;<br>  <span class="hljs-comment">// 存储所有注册的事件</span><br>  eventObj = &#123;&#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 注册回调</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; type 事件类型</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; cb 回调函数</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-title function_">on</span>(<span class="hljs-params">type, cb</span>) &#123;<br>    <span class="hljs-comment">// 如果注册类型不存在，初始化为一个数组</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">eventObj</span>[type]) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">eventObj</span>[type] = []<br>    &#125;<br>    <span class="hljs-comment">// 推入数组</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">eventObj</span>[type].<span class="hljs-title function_">push</span>(cb)<br>  &#125;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 触发订阅事件</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; type 事件类型</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-title function_">emit</span>(<span class="hljs-params">type, ...args</span>) &#123;<br>    <span class="hljs-comment">// 触发所有注册的事件</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">eventObj</span>[type] &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-property">eventObj</span>[type].<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">cb</span> =&gt;</span> cb.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args))<br>  &#125;<br>&#125;<br><span class="hljs-keyword">const</span> eventCenter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyEvent</span>()<br><br><span class="hljs-comment">// 订阅事件类型</span><br>eventCenter.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;hello&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;hello 事件被触发&#x27;</span>);<br>&#125;)<br>eventCenter.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;hello&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;hello 事件第二次被触发&#x27;</span>);<br>&#125;)<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">// 触发事件</span><br>  eventCenter.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;hello&#x27;</span>)<br>&#125;, <span class="hljs-number">1000</span>)<br><br></code></pre></td></tr></table></figure><p>上述代码是可以跑通的，你可以试着注册不同的事件验证效果。<br>如果你熟练用过发布订阅模式的库，你会发现除了订阅还能取消订阅，一般是 <code>off</code> 方法，下面我们来完善这个方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js">  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 取消订阅</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; type 事件类型</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; cb 回调函数 可选</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-title function_">off</span>(<span class="hljs-params">type, cb</span>) &#123;<br>    <span class="hljs-comment">// 如果没有传入指定的函数，代表取消所有监听</span><br>    <span class="hljs-keyword">const</span> fns = <span class="hljs-variable language_">this</span>.<span class="hljs-property">eventObj</span>[type]<br>    <span class="hljs-keyword">if</span> (!fns) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    <span class="hljs-keyword">if</span> (!cb) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">eventObj</span>[type] = []<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">return</span> fns.<span class="hljs-title function_">some</span>(<span class="hljs-function">(<span class="hljs-params">fn, i</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (fn === cb) &#123;<br>          fns.<span class="hljs-title function_">splice</span>(i, <span class="hljs-number">1</span>)<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>        &#125;<br>      &#125;)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们验证是否成功：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><br><span class="hljs-comment">// 订阅事件类型</span><br>eventCenter.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;hello&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;hello 事件被触发&#x27;</span>);<br>&#125;)<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">secondFn</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;hello 事件第二次被触发&#x27;</span>);<br>&#125;<br>eventCenter.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;hello&#x27;</span>, secondFn)<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  eventCenter.<span class="hljs-title function_">off</span>(<span class="hljs-string">&#x27;hello&#x27;</span>, secondFn)<br>  <span class="hljs-comment">// 触发事件</span><br>  eventCenter.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;hello&#x27;</span>)<br>&#125;, <span class="hljs-number">1000</span>)<br></code></pre></td></tr></table></figure><p>能看到我们赋予了匿名的箭头函数一个变量引用 <code>secondFn</code>，这对应了 <code>off</code> 函数里面第二个参数，只要订阅的函数和取消订阅的函数属于同一个引用，就能取消订阅。如果订阅的是一个匿名函数，是无法单独取消的，因为取消订阅的时候无法拿到匿名函数的引用，只能 <code>eventCenter.on(&#39;hello&#39;)</code> 取消 <code>hello</code> 订阅事件的所有订阅。</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
